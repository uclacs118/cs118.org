---
layout: ../../layouts/Assigment.astro
title: "Homework 2: HTTP, DNS, Error Recovery"
dueDate: 2025-02-04 23:59:00
---

Submit your homework solution PDF to Gradescope in any format you please;
however, make sure that each **question part** is on its own page.

# Question 1: HTTP (25 points)

1. **(9 points)** From class, we know that the `If-Modified-Since` header is used in HTTP Web Caching requests. Explain how this compares to the `If-None-Match` header. What header must the server send in responses to support `If-None-Match`? What benefits do we gain from this approach? (The [Mozilla docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching) are a great resource).

    The `If-None-Match` header uses the `ETag` in the server's previous responses to check for differences. (Typically the `ETag` is the hash of the response's value.) The main benefit is that we don't have to deal with timestamp semantics (potentially allowing for sub-second cache invalidation).

2. **(8 points)** HTTP Cookies (among other features) add state to what otherwise would be a stateless protocol. When visiting Piazza via Bruin Learn (the left-hand side tab), the browser sends the stored cookies to Piazza-proving your identity. Let's say that Piazza set its cookies with the attribute `SameSite=Strict`. Would we still be able to access Piazza inside an `iframe` within Bruin Learn (meaning Piazza is loaded cross-site)? What about `SameSite=Lax`? (Optional: by default, LTI integrations in Bruin Learn don't work in macOS Safari. Why is that?)

    If Piazza set its cookies' `SameSite` attribute to `Strict`, it would not work in the Bruin Learn `iframe` since it's considered cross-site. (The same applies to `SameSite=Lax` since the browser only relaxes a bit from `Strict` by sending cookies on referrer link.)

    LTI integrations in Bruin Learn don't work in macOS Safari since it prevents cross-site cookies.

3. **(8 points)** What improvements does HTTP/2 have over HTTP/1.1 to mitigate Head-of-Line blocking? Even with these mitigations, explain how HTTP/2 still suffers from HoL blocking.

    While HTTP/2 allows for multiplexing, it still has to send frames sequentially over a TCP connection. If one packet is dropped, the other packets may not be delivered to the application until the packet has been successfully recovered. 

# Question 2: DNS (25 points)

Professor Paul Eggert is fed up with UCLA IT. His high performance websites at `web.cs.ucla.edu` require the lowest latency access from any global location. Relying on UCLA servers alone won’t do. He’s experimenting with switching to Flarecloud—a global CDN network. 
To test this out, he asks his students to visit `beta.cs.ucla.edu`. This domain resolves to Flarecloud’s CDN servers (which caches his websites) instead of UCLA’s. 

One of his students decided to perform `dig` queries on both those domains.

```bash
$ dig web.cs.ucla.edu
[...]
;; QUESTION SECTION:
;web.cs.ucla.edu.	        IN      A

;; ANSWER SECTION:
web.cs.ucla.edu.	11702	IN	A	131.179.128.29

$ dig beta.cs.ucla.edu
[...]
;; QUESTION SECTION:
;beta.cs.ucla.edu.              IN      A

;; ANSWER SECTION:
beta.cs.ucla.edu.	11702	IN	CNAME   cdn.flarecloud.com
cdn.flarecloud.com.	172800	IN	A       162.159.38.2
```

Assume that:
- the student’s caching resolver is completely empty;
- only iterative resolution is used;
- `ns.ucla.edu` is the authoritative NS for all `ucla.edu` subdomains (there is no separate NS for `cs.ucla.edu`); and
- it takes 
    - **5** ms to contact the caching resolver,
    - **60** ms for the caching resolver to contact the `root`, `com`, and `edu` nameservers, and
    - **25** ms for the caching resolver to contact the Flarecloud and UCLA nameservers (all round trip).



1. **(10 points)** How long does it take to resolve `web.cs.ucla.edu`? Show all the steps needed to resolve this query.

    1. Firstly, we ask the caching resolver to determine the A record of `web.cs.ucla.edu`. **(2.5 ms)**
    2. The caching resolver now asks the root server for the same A record. It returns the NS and A records of `edu`'s nameserver. **(60 ms)**
    3. It now asks `edu`'s nameserver. It returns the NS and A records of `ucla.edu` (which is `ns.ucla.edu`). **(60 ms)**
    4. It now asks `ns.ucla.edu` for `web.cs.ucla.edu`. Since it's authoritative over all domains under `ucla.edu`, it returns the A record for `web.cs.ucla.edu`, which is our final answer. **(25 ms)**
    5. The caching resolver returns the answer to us. **(2.5 ms)**

    **Answer: 150 ms**

2. **(15 points)** How about `beta.cs.ucla.edu`? (Caches are present from the previous request-this is only asked a second later). Show all the steps needed to resolve this query.
    
    1. Firstly, we ask the caching resolver to determine the A record of `beta.cs.ucla.edu`. **(2.5 ms)**
    2. The caching resolver has since cached the A record of `ns.ucla.edu`. It asks it directly for `beta.cs.ucla.edu`, in which it returns the `CNAME` `cdn.flarecloud.com`. **(25 ms)**
    3. It now must resolve `cdn.flarecloud.com`. It asks the `root` server, and it returns the NS and A records of `com`'s nameserver. **(60 ms)**
    4. Now, it asks the `com` nameserver, in which it responds with the NS and A records of `flarecloud.com`. **(60 ms)**
    5. `flarecloud.com`'s nameserver returns the final A record to the caching resolver. **(25 ms)**
    6. The caching resolver returns the answer to us. **(2.5 ms)**

    **Answer: 175 ms**

# Question 3: Error Recovery (25 points)
*This question was written by Professor George Varghese.*

The figure below shows two examples of a Go-Back-N protocol working with a window size of **4** and a modulus of **4**. 
Recall that if the modulus is **4**, all sequence numbers and \\(\rm ACK\\)s are incremented modulo **4**. We want to show
that the modulus is too small. In both cases, the sender starts by sending the first **4** packets it is
allowed to in its current window (\\(P_0\\) through \\(P_3\\)) without waiting for an \\(\rm ACK\\).

Note: In this image, Go-Back-N ACKs the next expected packet, which is different than the textbook. **Just for this question**, assume that's how Go-Back-N works.

![q4](/imgs/hw2p4.svg)

1. **(5 points)** In case 1 shown on the left, the \\(\rm ACK\\) to the first data packet \\(P_0\\) is received.
On receipt of \\(\mathrm\{ACK\}_1\\), the window slides, and the sender sends a different \\(P_0\\) from the one it
sent earlier. 

    What should the receiver ideally do in this case? Specify how the receiver number 
    changes if it does, whether the data packet should be accepted, and what \\(\rm ACK\\) number should
    be sent back.

    Since this packet is not a retransmission, *ideally*, this packet should be accepted and sent over to the upper layer. The receiver number increases by 1, and it should send an ACK of 1.

2. **(5 points)** In Case 2 shown on the right, the \\(\rm ACK\\) to the first data packet \\(P_0\\) is lost.
After a timeout occurs, the sender retransmits the old \\(P_0\\). 

    What should the receiver do in
    this case? Specify how the receiver number changes if it does, whether the data packet should
    be accepted, and what \\(\rm ACK\\) number should be sent back.

    Since this packet is a retransmission, *ideally*, this packet should not be accepted and simply discarded. The receiver number does not change, and it should send an ACK of 0.

3. **(5 points)** Argue from these 2 cases, that the modulus is too small to work correctly.

    Even though these two cases are wildly different, the receiver sees the same thing-a packet with a sequence number of 0. Clearly, the modulus is too small since the packet namespace (0, 1, 2, 3) has a collision.

4. **(5 points)** Using the ideas in this example, argue briefly why the modulus should be at
least \\(w + 1\\), for a general window size of \\(w\\). (Try to make your argument general that works
for any \\(w\\) not just **4**.)

    With a modulus of \\(w+1\\), the receiver can tell the difference between these two cases. A retransmission will always have a sequence of 0, but moving onto the next window will have another sequence number \\(w\\) to refer to. There is no more collision.

5. **(5 points)** Explain how this relates to the Alternating Bit protocol (also known as Stop-and-Wait).

    Stop-and-Wait uses one bit (sequence numbers 0 and 1, or \\(w+1\\)) to control a window size of 1 (or \\(w\\)).

# Question 4: KEEPALIVE (25 points)
*This question was written by Professor George Varghese.*

Songwu Lu has been consulting with an Internet Service Provider and finds that they use an unusual error recovery protocol shown in the figure below. 

The protocol is very similar to Go-Back-N with numbered data packets; the key difference is that the receiver does not normally send ACKs. The receiver sends a message called a **NACK** only if it detects an error in the received sequence or if it receives a so-called **KEEPALIVE** packet. 

In the figure below, the sender sends off the first three data packets. The second one is lost; thus when the receiver gets the third packet, it detects an error and sends a **NACK** which contains the highest number the receiver has received in sequence. When **NACK** **1** gets to the sender, the sender retransmits data packets **2** and **3**. Periodically, based on a timer, the sender transmits a **KEEPALIVE** packet. The receiver always replies to a **KEEPALIVE** packet using a **NACK**.

![er](/imgs/er.svg)

1. **(5 points)** Why is the **KEEPALIVE** packet needed? What can go wrong if the sender does not send **KEEPALIVE** packets?

    The KEEPALIVE packet works like a retransmission timer. If everything goes completely right (all packets are not dropped and sent in order), the receiver will simply send no NACKs. If everything goes completely wrong (all packets are dropped), the receiver will also just send no NACKs. There must be some mechanism that periodically polls the receiver to make sure it has received everything.

2. **(5 points)** A **KEEPALIVE** packet is sent when a **KEEPALIVE** timer expires. The sender maintains the following property:  

   *While there remains unacknowledged data, the KEEPALIVE timer is running.* 

   Why does this property guarantee that any data packet given to the sender will eventually reach the receiver (as long as the link delivers most packets without errors)?

   As long as the KEEPALIVE timer is running, it will probe the receiver for progress. The receiver will send back an appropriate NACK, and the sender will retransmit if needed. This will keep on happening, and since most packets will deliver with no errors, eventually the NACK number will increase until there is no more unacknowledged data.

3. **(5 points)** Under what conditions must the timer be stopped and started to maintain the property?

    The timer must be started as soon as there's unacknowledged data (sending out packets with new data) and must be stopped when there is no more unacknowledged data (NACK number = last sent sequence number).

4. **(10 points)** Consider sending a single data packet **D** that is lost. After that, no packets get lost. What is the worst-case latency before the receiver receives **D** and the sender knows the receiver has received **D**? 

    Write your answer in terms of:
    - packet roundtrips (\\(\rm RTT\\); assume no transmission delays), and 
    - **KEEPALIVE** timer durations (\\(T\\)). 

    Assume that \\(\mathrm\{RTT\} \<\< T\\).

    There are two possible answers based on whether or not you assumed that receiving NACKs reset the KEEPALIVE timer.

    1. \\(L_T=0\\): The data packet **D** is sent, but is lost.
    2. \\(L_T=T\\): We wait for time **T** until we send a **KEEPALIVE** packet.
    3. \\(L_T=T+\rm RTT\\): The receiver sends back a NACK indicating that it hasn't received **D**. The sender retransmits **D**.
    4. \\(L_T=2T\\): The **KEEPALIVE** timer goes off, so we resend a **KEEPALIVE** packet. (This may happen at \\(L_T=2T+\rm RTT\\) if you assumed that we restart on NACK arrival.)
    5. \\(L_T=2T +\rm RTT\\): The receiver sends back a NACK indicating that it has received **D**. The sender now knows that data packet **D** was successfully transmitted. (This may happen at \\(L_T=2T+2\rm RTT\\) if you assumed that we restart on NACK arrival.)

    **Answer**: \\(L_T=2T +\rm RTT\\) or \\(L_T=2T+2\rm RTT\\) 




