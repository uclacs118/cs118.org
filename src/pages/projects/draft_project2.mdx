---
layout: ../../layouts/Assigment.astro
title: "Project 2: Security"
dueDate: 2025-03-19 23:59:00
---

# Quick Links

[**Starter Code**](https://github.com/uclacs118/project2starter)  
[**Using the Local Autograder**](/misc/autograder)

# Overview

In Project 1, you implemented a **reliable**, bidirectional pipe between two processes over the network. Congrats\! Your program is able to send data from any two locations over the internet in a reliable manner. 

When sending packets over the internet, tens of routers forward them to the correct destination. For example, see the output from the `traceroute` program that detects the forwarding path for `google.com`:

`$ traceroute -a -q 1 google.com`  
`traceroute to google.com (142.250.189.14), 64 hops max, 52 byte packets`  
 `1  [AS52[^1]] 164.67.62.83 (164.67.62.83)  21.406 ms`  
 `2  [AS52] 169.232.8.34 (169.232.8.34)  14.888 ms`  
 `3  [AS52] cr00f2.csb1--bd10f1.anderson.ucla.net (169.232.4.5)  18.035 ms`  
 `4  [AS2152] losa4-agg-01--ucla--50g--01.cenic.net (137.164.24.134)  16.358 ms`  
 `5  [AS15169] 142.250.173.78 (142.250.173.78)  30.159 ms`  
 `6  *`  
 `7  [AS15169] lax31s16-in-f14.1e100.net (142.250.189.14)  16.062 ms`

Not only do your packets to Google go through multiple routers, but also multiple Autonomous Systems (which are all under different management). How can we trust them to securely transfer our data over? Imagine we’re making an online purchase and giving Google our credit card number. How can we ensure that:

1. we’re actually giving Google our credit card and not some other entity—these routers could route our packets anywhere they want,  
2. only Google sees our credit card—these routers could read the data in our packets and buy things on our behalf, and  
3. the data we’re sending is accurate—these routers could change our data such that we’re buying thousands of dollars of some other product.

In this project, you’ll be implementing a security layer on top of the reliability layer created in Project 1\. Your security layer will ensure:

1. **identity**: both the client and the server can verify each other’s identity,  
2. **privacy**: all data is encrypted to avoid snooping, and  
3. **integrity**: all messages were not tampered with.

# Notices

1. If you’re using GitHub or a similar tool to track your work, please make sure that your repository is **set to private**.
2. As per the syllabus, the use of AI assisted tools is not allowed. Again, we can’t prove that such tools were used, but we do reserve the right to ask a couple questions about your solution and/or add project related questions to the exam.  
3. In the provided autograding Docker container, there are reference binaries. Please do not reverse engineer the binaries and submit that code—which would be obvious and clear academic dishonesty. Remember, we do manually inspect your code.  
4. This project must be done in groups of up to **3 people**. (Can be different from Project 1.)
5. **Make sure to select your highest score as your active submission before the deadline.**
6. **If you're in a group, use Gradescope's group feature to add your group members. Only one member must submit.**
7. Use `./helper zip` to create your submission if you plan on submitting by ZIP file.
8. A lot of material in this specification may seem foreign to you—that’s okay\! Make sure to review the [week 7 discussion slides](https://docs.google.com/presentation/u/0/d/1SZkgTgtq2ThsX17eb6RLZ9uy9ifoUFiKrYFW8CPwSJg/edit) which go over the intuition behind these new cryptographic protocols.

# Setup
Clone the [**Starter Code**](https://github.com/uclacs118/project2starter). The `helper` tools work exactly the same as Projects 0 and 1—see [**Using the Local Autograder**](/misc/autograder) for more info.

# Specification

Create two programs (a server and a client) written in C/C++ (up to version 17). Both programs will use [BSD sockets](https://en.wikipedia.org/wiki/Berkeley_sockets) using IPv4 and UDP to listen/connect. For cryptographic primitives, use `libcrypto` which is part of OpenSSL (version 3); the provided `libsecurity` does most of the heavy lifting for you. The expected behavior is the exact same as Project 1, but with different inner logic. See the [Project 0 specification](/projects/project0) and [Project 1 Specification](/projects/project1) for more information.

## Libraries
Like Project 0, we'll be using our own libraries. `libtransport` is essentially the solution to Project 1. You're free to use `libtransport` or to use your own solution to Project 1. See **[libtransport](/misc/libtransport)** for
more info. `libsecurity` has helper functions that help you use cryptographic primitives. See **[libsecurity](/misc/libsecurity)** for more info.

**Note: `libtransport` and `libsecurity` are only available in the Docker container.**
No other third party libraries are allowed.


## Quick Info

* **Algorithms and Formats**  
  * Message encoding uses [Type-Length-Value](https://en.wikipedia.org/wiki/Type%E2%80%93length%E2%80%93value)  
  * Key and signature format is in [ASN.1 DER](http://luca.ntop.org/Teaching/Appunti/asn1.html)  
  * Keys use the `NID_X9_62_prime256v1` elliptic curve  
  * Signatures use [ECDSA](https://learnmeabitcoin.com/technical/cryptography/elliptic-curve/ecdsa)  
  * Derive shared secret using Diffie-Hellman  
  * Encryption uses AES-256-CBC with PKCS \#7 padding  
    * \\(L_\{\mathrm\{plaintext\}\} = \left\lfloor\dfrac\{L_\{\mathrm\{payload\}\} - 60\}\{16\}\right\rfloor \cdot 16 - 1\\)
  * Key derivation uses HKDF SHA-256. Use info ENC for the encryption key and info MAC for the decryption key. No salt.  
  * Message authentication uses HMAC SHA-256—authenticate over the IV and ciphertext concatenated (in that order without the TLV header)  
* **Lengths**  
  * Public key length: **\~91 bytes**  
  * Nonce length: **32 bytes**  
  * Signature length: **70-72 bytes**  
  * IV length: **16 bytes**  
  * MAC length: **32 bytes**  
* **Files**  
  * CA signed server certificate: `server_cert.bin`  
  * Server private key: `server_key.bin`  
  * CA public key: `ca_public_key.bin`  
* **Exit Statuses**  
  * Bad certificate exit status: **1**  
  * Bad nonce exit status: **2**  
  * Bad MAC exit status: **3**  
  * Unexpected message exit status: **4**

## Type-Length-Value (TLV)

In Project 1, packets were defined according to strict boundaries; the SEQ was the first 2 bytes, the ACK was the next 2 bytes, and so on. For this Project 2, this is still true, but the security layer will define its messages differently. 

The security layer **will carry its messages in our reliability layer’s payload**. Here is how the security layer's messages look like:

```
                       Bits  
  0 1 2 3 4 5 6 7   
 +-+-+-+-+-+-+-+-+-+-+-+-+-+...+-+-+-+-+-+...  
 |      Type     | Length      | Value  
 +-+-+-+-+-+-+-+-+-+-+-+-+-+...+-+-+-+-+-+...
```

The first byte of the message is the type. For example, the type of the Client Hello message is 0x10. The next bytes of the message represent the length of the value. The number of bytes needed to encode the length is variable:
* If the length is less than or equal to 252 (0xFC), the length is encoded in one byte.
* If the length is greater than or equal to 253 (0xFD), the length is prepended with (0xFD) and then encoded in the following two bytes (in network order). For example, the number 255 (0xFF) is written as (0xFD, 0x00, 0xFF).

The last bytes of the message represent its value.

More formally:
```
TLV-TYPE = OCTET

VAR-NUMBER-1 = 0x00-0xFC
VAR-NUMBER-3 = 0xFD 2OCTET
TLV-LENGTH = VAR-NUMBER-1 / VAR-NUMBER-3

<message> = TLV-TYPE TLV-LENGTH *OCTET
```
**Note: `OCTET` is the same thing as a byte.**

We can also nest TLV messages recursively. For example, take our Client Hello definition:
```
NONCE-TYPE = 0x01
Nonce = NONCE-TYPE TLV-LENGTH 32OCTET

CLIENT-HELLO-TYPE = 0x10
Client-Hello = CLIENT-HELLO-TYPE TLV-LENGTH Nonce
```

The total size of a Client Hello message is 36 bytes. Why is that? The size of `Nonce` is 34 bytes: 32 bytes for its data (given by `32OCTET`), 1 byte for the `NONCE-TYPE`, and 1 byte for its `TLV-LENGTH` (since it's less than 252). Add another 2 bytes for `Client-Hello`'s type and length to get 36.

## General Operation

Before we send over any data from standard input, we must start with a handshake procedure. Please note that this is different from Project 1’s handshake. Remember, this is a completely separate layer from reliability—the security layer is a drop in replacement for standard input and standard output from the perspective of the reliability layer.

If you receive a message you’re not expecting (e.g. a Client Hello after you’ve sent a Server Hello), exit with **status code 4**.

### Client Hello

To start the handshake procedure, the client will send a Client Hello message. This message contains a random value (called a nonce). Keep track of this nonce—you will need it for a later step.

```
NONCE-TYPE = 0x01
Nonce = NONCE-TYPE TLV-LENGTH 32OCTET

CLIENT-HELLO-TYPE = 0x10
Client-Hello = CLIENT-HELLO-TYPE TLV-LENGTH Nonce
```

### Server Hello

After receiving the Client Hello, the server will construct and send its own Server Hello message. This message contains its own nonce (independent from the client’s nonce), its certificate, and a signature of the client’s nonce.

The certificate contains two values: a public key and a signature of your public key by the certificate authority. You’ll be able to access this certificate by reading the file `server_cert.bin` in the current working directory.

Note that the length of the public key and certificate is not deterministic. Typically, the public key is 91 bytes, the signature is around 72 bytes, but it could be 70, 71, or 72 bytes long[^2]. 

Sign the client’s nonce using your private key. Your private key is available by reading the file `server_key.bin` in the current working directory.

### Key Exchange Request

On receiving the Server Hello, the client will verify that:

1. The certificate was indeed signed by the certificate authority. This is done by verifying the signature in the certificate with the public key of the certificate authority. The CA’s public key is available by reading the file `ca_public_key.bin` in the current working directory. If the signature fails to verify, exit with **status 1**.  
2. The client nonce was indeed signed by the server. This is done by verifying the nonce signature in the Server Hello message with the public key in the server’s certificate. If the signature fails to verify, exit with **status 2**.

The client may now create a Key Exchange Request message. Firstly, it will generate a public/private key pair. Then, it will create a certificate in the same format (**`0xA0`**). Instead of the certificate authority signing the public key, the client will self-sign the public key using its own private key. 

We now have the server’s public key and our own. This is enough to derive a symmetric shared secret using Diffie-Hellman. Using HKDF, generate two other keys from the shared secret: an **ENC** key and a **MAC** key. These keys have their info strings as ENC and MAC respectively. Keep the salt empty.

Finally, it will sign the server’s nonce with its private key. 

### Finished

After receiving the Key Exchange Request, the server will verify that:

1. The certificate was indeed self-signed. If the signature fails to verify, exit with **status 1**.  
2. The server nonce was indeed signed by the client. If the signature fails to verify, exit with **status 2**. 

We now have the client’s public key and our own. This is enough to derive a symmetric shared secret using Diffie-Hellman. Using HKDF, generate two other keys from the shared secret: an **ENC** key and a **MAC** key.

To notify the client that the handshake is finished, send over a finished message:

### Data

Both sides may now send (encrypted) data over to each other. Read in from standard input the appropriate amount that the reliability layer says is available. (Remember, you might only be allowed to read a certain amount if the window is close to full.)

You’ll have to do some math to determine how much plaintext to encrypt. [See the discussion slides on CBC and PKCS \#7 padding](https://docs.google.com/presentation/d/1SZkgTgtq2ThsX17eb6RLZ9uy9ifoUFiKrYFW8CPwSJg). For example, to fill up a packet’s payload as much as possible:

* The max payload size is 1012\.  
* This leaves 1012 \- 3 (Data message header) \- 19 (IV message) \- 35 (MAC message) \- 3 (Ciphertext message header) \= 952 bytes for the ciphertext.  
* Each block is 16 bytes. The nearest multiple of 16 to 952 is 944\.   
* To prevent another 16 byte block being added, go one less than 944\.  
* The max plaintext size is 943 bytes.  
* [![][image1]](https://www.codecogs.com/eqnedit.php?latex=L_%7B%5Cmathrm%7Bplaintext%7D%7D%20%3D%20%5Cleft%5Clfloor%5Cdfrac%7BL_%7B%5Cmathrm%7Bpayload%7D%7D%20-%2060%7D%7B16%7D%5Cright%5Crfloor%20%5Ccdot%2016%20-%201#0)

Generate an initialization vector (random bytes, just like a nonce) and encrypt the appropriate amount of plaintext using the **ENC** key. Create an HMAC digest of your IV \+ ciphertext (append the two in that order without the TLV headers) using the **MAC** key.

When receiving data, firstly verify its integrity by calculating the HMAC digest of the received IV \+ ciphertext. If the digest matches the MAC code in the received Data message (exact memory comparison), proceed. If not, exit with **status 3**. 

Decrypt the ciphertext using the IV and output it to standard output.

# Uhhh, what did I just read?

Admittedly, this is a ton of new information. What’s important to note is that the provided [**Starter Files**](https://github.com/CS118F24/project2starter) do a lot of the heavy lifting. Read the function definitions in `security.h`. For example, the entire HKDF stuff is taken care of with the `derive_keys` function. The encrypt/decrypt functions and the HMAC function already use the appropriate keys. The point of this project is to help you learn about network security, but to also expose you to certain cryptographic technologies. You’re not expected to know how to use them from scratch, but simply be aware of their existence.

# Common Problems (list will be frequently updated)

* Make sure that **lengths** are in network order/big endian.

# Autograder Test Cases

**A word on the local autograder**: the autograder for Project 1 was mostly performance based—which created a huge diversion between local grading and Gradescope. Project 2, like Project 0, is correctness based. Theoretically, your local score and Gradescope should be the same. However, small differences in kernel versions may still cause discrepancies. As usual, your grade in Gradescope is your final grade.

## 0\. Compilation (`class` `TestCompilation`)

This test case passes if:

1. Your code compiles,  
2. yields two executables named `server` and `client`,  
3. and has no files that aren’t source code/text.

## 1\. Security (`class TestSecurity`)

1. **Handshake: Client Hello: `test_client_hello` (5 points)**  
   This test case runs your client executable against our reference server. Your client must send a valid Client Hello message to pass. Unlike the previous projects, we offer partial credit for each test case.

   Malformed message: **2.5 points**

2. **Handshake: Server Hello: `test_server_hello` (20 points)**  
   Same as 1, but using your server executable to assess valid Server Hello messages.

   Malformed message: **10 points**

3. **Handshake: Key Exchange Request: `test_key_exchange_request` (30 points)**  
   Same as 1, but assessing valid Key Exchange Request messages and the client’s ability to verify information in the Server Hello. Log messages that test your client with bad CA public keys are appended with **`badcert`**. Log messages that test your client with bad server private keys (an impostor) are appended with **`badpriv`**.

   Malformed message: **5 points**  
   Correct message, but does not perform certificate verification: **10 points**  
   Correct message, but does not perform nonce verification: **20 points**

4. **Handshake: Finished: `test_finished` (5 points)**  
   Same as 2, but assessing valid Finished messages.

   Malformed message: **2.5 points**

5. **Encrypt and MAC: Client: `test_encrypt_and_mac_client` (15 points)**  
   This test case runs your client executable against our reference server. Your client must encrypt and decrypt data according to the spec. It must also determine when messages with bad authentication codes are sent.

   Either encryption or decryption is faulty: **5 points**  
   Encryption/decryption are valid, but does not perform message authentication: **10 points**

6. **Encrypt and MAC: Server: `test_encrypt_and_mac_server` (15 points)**  
   Same as 5, but using your server executable against our reference client.

## Description of Work (10 points)

We ask you to include a file called `README.md` that contains a quick description of:

1. the design choices you made,  
2. any problems you encountered while creating your solution, and  
3. your solutions to those problems.

This is not meant to be comprehensive; less than 300 words will suffice.

# Submission Requirements

Submit a ZIP file, GitHub repo, or Bitbucket repo to Gradescope by the posted deadline. You have unlimited submissions; we’ll choose your best scoring one. As per the syllabus, remember that all code is subject to manual inspection.

In your ZIP file, include all your source code (including `security.c/h`) \+ `README.md` \+ a `Makefile` that generates two executables named `server` and `client`. **Do not include any other files; the autograder will reject submissions with those.** If you’re using the starter repository, the default `Makefile` inside the `project` directory includes a `zip` directive that automatically creates a compatible ZIP file.

[^1]:  Fun fact: Autonomous System 52 is UCLA.

[^2]:  This is due to how the ECDSA algorithm is nondeterministic. See [https://learnmeabitcoin.com/technical/cryptography/elliptic-curve/ecdsa/](https://learnmeabitcoin.com/technical/cryptography/elliptic-curve/ecdsa/) if you’re curious.

[image1]: <data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAPEAAAAnBAMAAAAsgrMIAAAAMFBMVEX///8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAv3aB7AAAAD3RSTlMAq+/dzbtUZplEIol2MhAtEXdVAAAAOklEQVR4Xu3NIQEAIADAMKB/WRKAJ8Awn7z5POOPvd7CdJY6S52lzlJnqbPUWeosdZY6S52lztK/8wV5YgI+lV12FAAAAABJRU5ErkJggg==>
