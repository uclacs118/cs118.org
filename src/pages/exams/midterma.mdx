---
layout: ../../layouts/Assigment.astro
title: "Midterm (Version A)"
---

# Question 1: DNS (25 points)

In lecture, we discussed that DNS’s operation is separate from its namespace design and that a
typical example is CDNs. This problem introduces a slightly more complex scenario where the domain
CDN service and DNS service are provided by the same entity (for example, Cloudflare).

Our course website `cs118.org` is using Cloudflare as a **CDN service and DNS service**. That is, the
name server of `cs118.org` is actually under `cloudflare.com` (for example, `ns1.cloudflare.com`).

When you query the `.org` name servers for `cs118.org`, it refers to `ns1.cloudflare.com`. When
`ns1.cloudflare.com` receives a DNS query for `cs118.org`, it returns the IP address of the closest
Cloudflare box to the requester, so that your browser can load `cs118.org` home page with minimal
latency.

We also assume that:
- The `.org` and `.me` name servers do not provide the **A** record of `ns1.cloudflare.com` (that
means the local resolver needs to query it by itself!).
- `ns1.cloudflare.com` is the only name server of `cloudflare.com`.
- The cache is empty. Root name servers’ IP addresses are hard-coded in implementation already.
- The RTT between your laptop and your cache resolver is \\(10\\;\rm ms\\). The RTT between the cache
resolver and any name server is \\(50\\;\rm ms\\).
- The TTLs of all TLD (Top Level Domain) RRs (e.g., **NS** and **A** records of `.org`) are fixed as \\(600\\;\rm s\\)
and all other RR TTLs are fixed as \\(60\\;\rm s\\).

Our TA, Omar, also has his two websites `eado.me` and `elamri.me` hosted by Cloudflare in the same
way (i.e., for CDN service and DNS service). The **NS** record of both domains also point to
`ns1.cloudflare.com`. Let’s consider following DNS queries.

1. **(7 points)** At \\(T = 0\\;\rm s\\), your laptop queries the **A** record of `cs118.org`. When will your laptop
receive the final answer?

    1. Firstly, we ask the caching resolver to resolve `cs118.org`. **(5 ms)**

    2. The caching resolver asks the root servers for the A record of `cs118.org`. It receives the NS record and the A record for the `org` nameserver. **(50 ms)**

    3. It now asks the `org` nameserver for the A record of `cs118.org`. It only receives the NS record for `cs118.org`, which is `ns1.cloudflare.com`. **(50 ms)**

    4. The caching resolver must now resolve `ns1.cloudflare.com`. It asks the root servers for the A record of `ns1.cloudflare.com`, and receives both the NS and A records for the `com` nameserver. **(50 ms)**

    5. It asks the `com` nameserver for the A record of `ns1.cloudflare.com`. It receives the NS and A records for the `cloudflare.com` nameserver, which happens to be `ns1.cloudflare.com`! **(50 ms)**

    6. It can now ask this nameserver for the A record of `cs118.org`, which yields the final result. **(50 ms)**

    7. The caching resolver returns this result to us. **(5 ms)**

    **Answer: 260 ms** (or \\(T=0.260\\;\rm s\\))

2. **(6 points)** At \\(T = 30\\;\rm s\\), your laptop queries the **A** record of `eado.me`. When will your laptop
receive the final answer?

    1. Firstly, we ask the caching resolver to resolve `eado.me`. **(5 ms)**

    2. The caching resolver asks the root servers for the A record of `eado.me`. It receives the NS record and the A record for the `me` nameserver. **(50 ms)**

    3. It now asks the `me` nameserver for the A record of `eado.me`. It only receives the NS record for `eado.me`, which is `ns1.cloudflare.com`. **(50 ms)**

    4. The caching resolver already knows the A record of `ns1.cloudflare.com` (TTL: \\(30\\;\rm s\\)). It asks it for the A record of `eado.me` and receives it. **(50 ms)**

    5. The caching resolver returns this result to us. **(5 ms)**

    **Answer: 160 ms** (or \\(T=30.160\\;\rm s\\))

3. **(6 points)** At \\(T = 610\\;\rm s\\), your laptop queries the **A** record of `eado.me` again. When will your laptop receive the final answer?

    1. Firstly, we ask the caching resolver to resolve `eado.me`. **(5 ms)**

    2. The RRs for `eado.me` have expired, so the caching resolver must resolve it. However, it already knows the A record of `me`'s nameserver (TTL: \\(20\\;\rm s\\)), so it asks it for the A record of `eado.me`. It only receives the NS record for `eado.me`, which is `ns1.cloudflare.com`. **(50 ms)**

    3. Unfortunately, the `com` nameserver RRs have since expired, so the caching resolver must now resolve `ns1.cloudflare.com` (which has also expired) from the start. It asks the root servers for the A record of `ns1.cloudflare.com`, and receives both the NS and A records for the `com` nameserver. **(50 ms)**

    4. It asks the `com` nameserver for the A record of `ns1.cloudflare.com`. It receives the NS and A records for the `cloudflare.com` nameserver, which happens to be `ns1.cloudflare.com`. **(50 ms)**

    5. It can now ask this nameserver for the A record of `eado.me`, which yields the final result. **(50 ms)**

    6. The caching resolver returns this result to us. **(5 ms)**

    **Answer: 210 ms** (or \\(T=610.210\\;\rm s\\))

4. **(6 points)** At \\(T = 680\\;\rm s\\), your laptop queries the **A** record of `elamri.me`. When will your laptop receive the final answer?

    1. Firstly, we ask the caching resolver to resolve `elamri.me`. **(5 ms)**

    2. Unfortunately, the `me` nameserver RRs have expired, so the caching resolver must resolve `elamri.me` from the start. It asks the root servers for the A record of `elamri.me`, and receives both the NS and A records for the `me` nameserver. **(50 ms)**

    3. It asks the `me` nameserver for the A record of `elamri.me`. It only receives the NS record for `elamri.me`, which is `ns1.cloudflare.com`. **(50 ms)**

    4. The RRs for `ns1.cloudflare.com` have since expired, so the caching resolver must resolve it. However, it already knows the A record of `com`'s nameserver (TTL: \\(530\\;\rm s\\)). It asks the `com` nameserver for the A record of `ns1.cloudflare.com`. It receives the NS and A records for the `cloudflare.com` nameserver, which happens to be `ns1.cloudflare.com`. **(50 ms)**

    5. It can now ask this nameserver for the A record of `elamri.me`, which yields the final result. **(50 ms)**

    6. The caching resolver returns this result to us. **(5 ms)**

    **Answer: 210 ms** (or \\(T=680.210\\;\rm s\\))


# Question 2: Bandwidth and Delay (25 points)

![problem](/imgs/midap2.svg)

Host \\(A\\) continuously sends **4** packets to Host \\(B\\) via 2 routers \\(R_1\\) and \\(R_2\\).
- The packet length is \\(500\\;\rm bytes\\) each.
- The \\(A-R_1\\) and \\(R_2-B\\) links each have \\(4\\;\rm Mbps\\) of bandwidth and \\(1\\;\rm ms\\) of propagation delay.
- The \\(R_1-R_2\\) link has \\(1\\;\rm Mbps\\) of bandwidth, \\(2\\;\rm ms\\) of propagation delay.
Assume Host \\(A\\) starts transmitting the first packet at time \\(T = 0\\;\rm s\\).

1. **(7 points)** What is the time gap between the first and third packets when they arrive at \\(R_2\\)? (i.e.
the time gap between receiving the last bit of the first packet and the last bit of 3rd packet).

    Referencing the table, we see that 16 ms - 8 ms = **8 ms**. (CAE/Forgotten Alternate: 4 ms)

2. **(7 points)** What is the time gap between the first and third packets when they arrive at Host \\(B\\)?

    Referencing the table, we see that 18 ms - 10 ms = **8 ms**. (CAE/Forgotten Alternate: 4 ms)

3. **(11 points)** When will Host \\(B\\) receive all 4 packets?

    Referencing the table, we see that packet 4 completely arrives at \\(B\\) at **22 ms**. (CAE/Forgotten Alternate: 13 ms)

\\(A-R_1\\) and \\(R_2-B\\) transmission time for one packet: \\(1\\;\rm ms\\)  
\\(R_1-R_2\\) transmission time for one packet: \\(4\\;\rm ms\\)

|Packet|Leaving A|Arriving R1|Leaving R1|Arriving R2|Leaving R2|Arriving B|
|---   |---      |---        |---       |---        |---       |---       |
|1     |1ms      |2ms        |6ms       |8ms        |9ms       |10ms      |
|2     |2ms      |3ms        |10ms      |12ms       |13ms      |14ms      |
|3     |3ms      |4ms        |14ms      |16ms       |17ms      |18ms      |
|4     |4ms      |5ms        |18ms      |20ms       |21ms      |22ms      |

(If you had CAE accomodations or forgot to change 500 to 250, your table looks like this):

\\(A-R_1\\) and \\(R_2-B\\) transmission time for one packet: \\(0.5\\;\rm ms\\)  
\\(R_1-R_2\\) transmission time for one packet: \\(2\\;\rm ms\\)

|Packet|Leaving A|Arriving R1|Leaving R1|Arriving R2|Leaving R2|Arriving B|
|---   |---      |---        |---       |---        |---       |---       |
|1     |0.5ms    |1.5ms      |3.5ms     |5.5ms      |6ms       |7ms       |
|2     |1ms      |2ms        |5.5ms     |7.5ms      |8ms       |9ms       |
|3     |1.5ms    |2.5ms      |7.5ms     |9.5ms      |10ms      |11ms      |
|4     |2ms      |3ms        |9.5ms     |11.5ms     |12ms      |13ms      |

# Question 3: Utilization (25 points)

With the same connectivity and topology shown from the last problem, Host \\(A\\) sends a very big (big
enough so that it takes infinite time to finish) file to Host \\(B\\), using packets size of \\(1000\\;\rm bytes\\). We
assume that the acknowledgment sent by \\(B\\) to \\(A\\) is small in size with negligible transmission delay.

1. **(12 points)** If the transmission uses the stop-and-wait approach (Host \\(A\\) waits for acknowledgment of each packet before sending the next one), what is the utilization of the \\(A—R_1\\) link?
(Utilization = the percentage of time that the \\(A—R_1\\) link is busy transmitting packets).

- For a \\(1000\\;\rm byte\\) packet to arrive at \\(B\\), it takes:
    - \\(2\\;\rm ms\\) to transmit across the \\(A-R_1\\) link (and \\(1\\;\rm ms\\) propagation time).
    - \\(8\\;\rm ms\\) to transmit across the \\(R_1-R_2\\) link (and \\(2\\;\rm ms\\) propagation time).
    - \\(2\\;\rm ms\\) to transmit across the \\(R_2-B\\) link (and \\(1\\;\rm ms\\) propagation time).
- For the acknowledgement to return to \\(A\\), we add up all the propagation times: \\(1\\;\mathrm\{ms\} + 2\\;\mathrm\{ms\} + 1\\;\mathrm\{ms\} = 4\\;\mathrm\{ms\}\\)

Adding up all these times, it takes \\(2\\;\mathrm\{ms\}+8\\;\mathrm\{ms\}+2\\;\mathrm\{ms\}+4\\;\mathrm\{ms\}+4\\;\mathrm\{ms\} = 20\\;\mathrm\{ms\}\\) to send one packet and receive its acknowlegement. 

During this time, we spend only \\(2\\;\mathrm\{ms\}\\) transmitting a packet across the \\(A-R_1\\) link. This results in \\(2 \\;\mathrm\{ms\} / 20 \\;\mathrm\{ms\} = \\) **10% utilization**.

2. **(13 points)** Assume \\(A\\) and \\(B\\) switch to use the Go-Back-N approach but without a retransmission timer (Host \\(A\\) can send \\(N\\) packets before waiting for ACKs). Both \\(R_1\\) and \\(R_2\\) have large but
finite sizes for their packet buffers (therefore, you cannot have infinite queuing delay before
packets start dropping). In the absence of packet losses caused by the links themselves, what is
the minimal value of \\(N\\) that allows Host \\(A\\) to achieve the maximum possible throughput without
packet losses?

Essentially, we want to make it such that the queue at \\(R_1\\)'s receiving buffer does not get overrun (since it's the bottleneck). Packets at \\(R_1\\)'s receiving buffer leave bounded by the transmission speed of the \\(R_1-R_2\\) link. By limiting \\(N\\) to send as many packets across this link within a packet round (the interval between sending the first bit of a packet and receiving its acknowledgement), we can send at the maximum throughput (with no packet losses).

From the previous part, a packet round is \\(20\\;\rm ms\\), and the transmission time across the \\(R_1-R_2\\) link is \\(8\\;\rm ms\\).

\\(20 \\;\mathrm\{ms\} / 8 \\;\mathrm\{ms\} = 2.5\\) and rounding up yields a minimum of **3 packets**.

# Question 4: HTTP + TCP (25 points)

A browser uses HTTP/1.0 to load a index page from a web server. The index page itself has \\(500\\) bytes,
and it only refers to one picture with a size of \\(1000\\) bytes. For simplicity, let us assume that:

- there are no packet losses, out-of-order arrivals, and retransmissions;
- the TCP flow control window and congestion control window are fixed at \\(500\\;\rm KB\\) and the maximum segment size (MSS) is \\(1460\\;\rm bytes\\);
- the browser and server send an `ACK` immediately upon receiving an information or data segment
that needs an acknowledgment (therefore no delayed ACK);
- data is piggybacked to the last packet of TCP 3-way handshake;
- `FIN` and `FIN-ACK` (or `ACK` for `FIN`) are also sent in one TCP segment); and
- all HTTP headers (request and response) are \\(20\\;\rm bytes\\), and all HTTP request payloads are \\(50\\;\rm bytes\\).

1. **(7 points)** How many TCP segments in total do the browser and web server send to each other
during this process? Please make a list to show what each packet does. For example, \\(P_1\\) is the
connection request (TCP `SYN`) and \\(P_2\\) is the connection accept (TCP `SYN-ACK`).

    Since this is HTTP/1.0, we can only send one request/response pair within a single TCP connection. The server closes the connection. Since `cwnd` and `rwnd` are \\(500\\;\rm KB\\), we don't need to worry about them. Since the MSS is \\(1460\\;\rm bytes\\) we know that all objects can be transmitted in one packet. 

    1. Client: TCP `SYN`
    2. Server: TCP `SYN-ACK`
    3. Client: TCP `ACK` + HTTP GET Request for `index.html`
    4. Server: TCP `ACK` + HTTP GET Response for `index.html`
    5. Server: TCP `FIN`
    6. Client: TCP `ACK` (Optional)
    7. Client: TCP `FIN-ACK`
    8. Server: TCP `ACK`

    The same process occurs for the picture, which doubles the message count, yielding a total of **16 messages**.
    (If you didn't include packet 6 (the client packet ACKing the response), that's okay. We'll also accept **14 messages**).

2. **(7 points)** Now, let’s assume that the browser uses HTTP/1.1 (for the sake of saving RTTs) to
load the same page and that the server supports HTTP/1.1. How many TCP segments total do
the browser and web server send to each other during this process?

    Since this is HTTP/1.1, we can send as multiple request/response pairs within a single TCP connection. The client closes the connection.

    1. Client: TCP `SYN`
    2. Server: TCP `SYN-ACK`
    3. Client: TCP `ACK` + HTTP GET Request for `index.html`
    4. Server: TCP `ACK` + HTTP GET Response for `index.html`
    5. Client: TCP `ACK` + HTTP GET Request for the image
    6. Server: TCP `ACK` + HTTP GET Response for the image
    7. Client: TCP `ACK` (Optional)
    8. Client: TCP `FIN`
    9. Server: TCP `FIN-ACK`
    10. Client: TCP `ACK`

    This is a total of **10 messages**. (If you didn't include packet 7 (the client packet ACKing the response), that's okay. We'll also accept **9 messages**.)

3. **(11 points)** Let’s assume that we’re using HTTP/1.1, the browser picks an initial sequence number **1234** and source port **3000**, the server picks an initial sequence number **7890**, and the
web service runs on port **80**. Write the source port, destination port, sequence number, and
acknowledgment number of \\(P_3\\), \\(P_4\\), and the last packet transmitted.

    All client packets have source and destination ports of 3000 and 80 respectively.
    All server packets have source and destination ports of 80 and 3000 respectively.

    The last number in each packet isn't required, but shows the number of bytes "consumed."

    1. Client: Seq (1234), ACK (-) 1
    2. Server: Seq (7890), ACK (1235) 1
    3. **Client: Seq (1235), ACK (7891) 70**
    4. **Server: Seq (7891), ACK (1305) 520**
    5. Client: Seq (1305), ACK (8411) 70
    6. Server: Seq (8411), ACK (1375) 1020
    7. Client: Seq (1375), ACK (9431) 0 (Optional)
    8. Client: Seq (1375), ACK (9431) 1
    9. Server: Seq (9431), ACK (1376) 1
    10. **Client: Seq (1376), ACK (9432) 0**
